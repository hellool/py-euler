Divisors

Lets look at problem 12 for this one:

===
Highly divisible triangular number

Problem 12
The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:

1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

Let us list the factors of the first seven triangle numbers:

 1: 1
 3: 1,3
 6: 1,2,3,6
10: 1,2,5,10
15: 1,3,5,15
21: 1,3,7,21
28: 1,2,4,7,14,28
We can see that 28 is the first triangle number to have over five divisors.

What is the value of the first triangle number to have over five hundred divisors?
===

This is the first problem we encounter where we need to compute divisors (or at least the number of them)

There is a convenient formula for triangular numbers, so we don't actually need to sum N number to compute the Nth triangular number. Starting with n = 1, it is:
f(x) = n(n+1)/2
f(1) = 1
f(2) = 3
and so on

How many numbers to we have to check to find all the divisors of n? The upper bound is n-1, since all divisors must be less than n. We don't need to go that far though. The optimization is very similar to optimizing a prime sieve method as discussed in _primes.txt.

Observe that if d divides n and d < sqrt(n), then n/d also divides n and n/d > sqrt(n). There could never be a pair of divisors both larger than the square root, as their product would be larger than n. Any divisor n/d that is larger than sqrt(n) will be discovered when d is. This means we really only need to check potential divisors up to sqrt(n), and we will have discovered all divisors of n. 

Lets see if this method is fast enough to solve the original problem. We'll write a function that iterates through the triangular numbers and prints one out when it reaches a new record of divisors. First we'll write a helper function to get the list of divisors.

def list_divisors_brute_force(n):
	if n < 1:
		return [1]
	div_list = [1]
	for d in range(2, int(pow(n, 0.5) + 1)):
		if n%d == 0:
			div_list.append(n)
			div_list.append(n//d)
	return div_list
	
def tri_divisiors(n):
	for i in range(1, n+1):
		tri = i*(i+1) // 2
		divisors = list_divisors_brute_force(tri)
		num_divs = len(divisors)
		if num_divs > max_divs:
			divs.sort()
			max_divs = num_divs
			print(i, tri, num_divs, divs)

tri_divisors(100)
		
	
