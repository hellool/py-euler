Divisors

Lets look at problem 12 for this one:

===
Highly divisible triangular number

Problem 12
The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:

1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

Let us list the factors of the first seven triangle numbers:

 1: 1
 3: 1,3
 6: 1,2,3,6
10: 1,2,5,10
15: 1,3,5,15
21: 1,3,7,21
28: 1,2,4,7,14,28
We can see that 28 is the first triangle number to have over five divisors.

What is the value of the first triangle number to have over five hundred divisors?
===

This is the first problem we encounter where we need to compute divisors (or at least the number of them)

There is a convenient formula for triangular numbers, so we don't actually need to sum N number to compute the Nth triangular number. Starting with n = 1, it is:
f(x) = n(n+1)/2
f(1) = 1
f(2) = 3
and so on

How many numbers do we have to check to find all the divisors of n? The upper bound is n-1, since all divisors must be less than n. We don't need to go that far though. The optimization is very similar to optimizing a prime sieve method as discussed in _primes.txt.

Observe that if d divides n and d < sqrt(n), then n/d also divides n and n/d > sqrt(n). There could never be a pair of divisors of n both larger than the square root, as their product would be larger than n. Any divisor n/d that is larger than sqrt(n) will be discovered when d is discovered. This means we really only need to check potential divisors up to sqrt(n), and we will have discovered all divisors of n. 

Lets see if this method is fast enough to solve the original problem. We'll write a function that iterates through the triangular numbers and prints one out when it reaches a new record of divisors. First we'll write a helper function to get the list of divisors.

def list_divisors_brute_force(n):
    if n < 2:
        return [1]
    div_list = [1]
    for d in range(2, int(pow(n, 0.5) + 1)):
        if n%d == 0:
            div_list.append(d)
            div_list.append(n//d)
    return div_list
	
def tri_divisors(n, divs_limit = 499):
    max_divs = 0
    for i in range(1, n+1):
        tri = i*(i+1) // 2
        divisors = list_divisors_brute_force(tri)
        num_divs = len(divisors)
        if num_divs > max_divs:
            divisors.sort()
            max_divs = num_divs
            print(i, tri, num_divs, divisors)
			#print(i, tri, num_divs) #use when list gets too long
            if max_divs > divs_limit:
                break

tri_divisors(1000)

===
running this, we can see it prints out the new records up through the 935th triangle number, the last to reach a new divisor high. With only 143, we will have to increase the number tried. Printing out the full list is unncessary now that we can verify it's correct, so we'll change the print line to leave that out for cleanliness.

tri_divisors(10000)

It takes a few seconds on my PC, but we end up with the 5984th tri number having 479 divisors. Almost there! Lets try doubling n.

tri_divisors(20000)

It takes a few more seconds but we got the solution this time.

===
This solution did not use lookup tables, which can considerably reduce the complexity of finding divisors. For more information, see the discussion _recursive_with_lookup.txt.

