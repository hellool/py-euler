Pythagorean triplets

Lets look at Problem 9:
===
A Pythagorean triplet is a set of three natural numbers, a < b < c, for which,

a^2 + b^2 = c^2
For example, 32 + 42 = 9 + 16 = 25 = 52.

There exists exactly one Pythagorean triplet for which a + b + c = 1000.
Find the product abc.
===

This problem is the same as asking us to find the right triangle with a total side length of 1000. There is indeed only one, and it's possible to prove (we won't do that here).

This problem is not particularly hard to solve through brute force. The total length is 1000 and a side can't be zero, so the side lengths have to range between 1 and 998. If we checked every possible combination of numbers we would have 998^3 or a little under a billion solutions to check, which is reasonable to do although it may take a while. However we know that a+b+c = 1000, so once we know a and b there is only one c that could possible result in a solution. Thus there are really only 998^2 solutions we need to check this way, which is not hard at all to do. We also only need to consider solutions where a < b which lets us cut our checks in half, approximately. Lets write some code for this simple solution. 

===
def brute_force_soln():
	for a in range(1, 999): #can be between 1 and 998
		for b in range(a+1, 1000): #can be between (a+1) and 999
			c = 1000 - a - b
			if a**2 + b**2 == c**2:
				print("found a solution! a = {}, b = {}, c = {}. Product = {}".format(a, b, c, a*b*c))
===

This code works great and runs in less than a second on my PC. But what if the sum you were looking for wasn't 1000? What if it was on the order of 1 million? That would take a million times as long to find a solution for, on average with this approach (1000 times as long for a and for b). Or what if it was 100 million? This is where we need to better understand Pythagorean triples to construct a more general solution to this problem. 

===EUCLID'S FORMULA===

Euclid's formula is a fundamental formula for generating triples given positive integers m and n, such that m > n > 0. The formula states that:
a = m^2 - n^2
b = 2*m*n
c = m^2 + n^2
... will always form a fundamental Pythagorean triple or Right triangle. A fundamental triple is one where none of the sides share a divisor. E.g. the triple (3,4,5) is fundamental and can be generated with this formula where m = 2 and n =1. But (6,8,10) is not since it is just the first with all sides multiplied by 2. ANY Pythagorean triple can thus be generated by a unique pair of m and n, plus a scaling factor.

===

Why is this formula important? Recall that the problem asks us for a triple that sums up to a specific total side length. If we multiply a triple by a scaling factor, that side length is multiplied by the same factor. That means that if we find a *fundmanetal* triple with total side length of, say, 12, we have also then found triples with side lengths of 24, 36, 120, 120000, etc. Any multiple of that side length can be easily produced with the same pair of (m, n). This means we don't *really* need to look through all (a, b, c) combinations that sum to 1000 and then check if it's a Pythagorean triple. We can instead look through all (m, n) combinations until we find one that generates a triple with total side length that divides 1000, which is easily checked. This turns out to be much faster. Substituting using our formula, we find that:

a + b + c = m^2 - n^2 + 2*m*n + m^2 + n^2 = 2*m^2 + 2*m*n = 2*m*(m+n)

Which gives us a simple formula to calculate the total side length. One nice thing about this formula is that it give us some convenient bounds on possible values for m and n. The smallest n is 1, which reduces the formula to 2*m^2. If our target is 1000, that means m can be no larger than the square root of (1000/2), which is ~22.36. So the largest possible m is 22, which means at the very most we would have only 22*21 = 462 fundamental triples to check, as opposed to ~1 million or so possible solutions with the brute force method. Recall that the brute force solution scaled proportionally to the *square* of the side length, L^2. By contrast, the method using Euclid's parameters scales with the *root* of the side length, L^(0.5). It is *tremendously* more efficient, thanks to the mathematical knowledge of constructing Pythagorean triples instead of just checking each possibility.

def euclid_solution(target_L):
	#target_L is the desired total side length or sum of the triple, 1000 in the original problem
	max_m = int(pow(target_L, 0.5) / 2)
	for m in range(1, max_m+1): #ranges from 1 to max_m
		for n in range(1, m): #ranges from 1 to m-1
			L = 2*m*(m+n)
			if L > target_L: 
				break #m, n pair is too large, so reset n to 1 and increase m by 1
			if target_L % L == 0: #hit!
				scaling_factor = target_L // L
				a = scaling_factor * (m**2 + n**2)
				b= scaling_factor * (2*m*n)
				c = scaling_factor * (m**2 - n**2)
				print("Found triple a = {}, b = {}, c = {}. Product = {}".format(a, b, c, a*b*c))
				
				
			
	




